
//// Automatically Generated by SwiftSyntaxBuilderGeneration
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax

/// Namespace for commonly used tokens with default trivia.
public extension TokenSyntax {
  
/// The `associatedtype` keyword
static var `associatedtype`: TokenSyntax {
    SyntaxFactory.makeAssociatedtypeKeyword()
  }
  
/// The `class` keyword
static var `class`: TokenSyntax {
    SyntaxFactory.makeClassKeyword()
  }
  
/// The `deinit` keyword
static var `deinit`: TokenSyntax {
    SyntaxFactory.makeDeinitKeyword()
  }
  
/// The `enum` keyword
static var `enum`: TokenSyntax {
    SyntaxFactory.makeEnumKeyword()
  }
  
/// The `extension` keyword
static var `extension`: TokenSyntax {
    SyntaxFactory.makeExtensionKeyword()
  }
  
/// The `func` keyword
static var `func`: TokenSyntax {
    SyntaxFactory.makeFuncKeyword()
  }
  
/// The `import` keyword
static var `import`: TokenSyntax {
    SyntaxFactory.makeImportKeyword()
  }
  
/// The `init` keyword
static var `init`: TokenSyntax {
    SyntaxFactory.makeInitKeyword()
  }
  
/// The `inout` keyword
static var `inout`: TokenSyntax {
    SyntaxFactory.makeInoutKeyword()
  }
  
/// The `let` keyword
static var `let`: TokenSyntax {
    SyntaxFactory.makeLetKeyword()
  }
  
/// The `operator` keyword
static var `operator`: TokenSyntax {
    SyntaxFactory.makeOperatorKeyword()
  }
  
/// The `precedencegroup` keyword
static var `precedencegroup`: TokenSyntax {
    SyntaxFactory.makePrecedencegroupKeyword()
  }
  
/// The `protocol` keyword
static var `protocol`: TokenSyntax {
    SyntaxFactory.makeProtocolKeyword()
  }
  
/// The `struct` keyword
static var `struct`: TokenSyntax {
    SyntaxFactory.makeStructKeyword()
  }
  
/// The `subscript` keyword
static var `subscript`: TokenSyntax {
    SyntaxFactory.makeSubscriptKeyword()
  }
  
/// The `typealias` keyword
static var `typealias`: TokenSyntax {
    SyntaxFactory.makeTypealiasKeyword()
  }
  
/// The `var` keyword
static var `var`: TokenSyntax {
    SyntaxFactory.makeVarKeyword()
  }
  
/// The `fileprivate` keyword
static var `fileprivate`: TokenSyntax {
    SyntaxFactory.makeFileprivateKeyword()
  }
  
/// The `internal` keyword
static var `internal`: TokenSyntax {
    SyntaxFactory.makeInternalKeyword()
  }
  
/// The `private` keyword
static var `private`: TokenSyntax {
    SyntaxFactory.makePrivateKeyword()
  }
  
/// The `public` keyword
static var `public`: TokenSyntax {
    SyntaxFactory.makePublicKeyword()
  }
  
/// The `static` keyword
static var `static`: TokenSyntax {
    SyntaxFactory.makeStaticKeyword()
  }
  
/// The `defer` keyword
static var `defer`: TokenSyntax {
    SyntaxFactory.makeDeferKeyword()
  }
  
/// The `if` keyword
static var `if`: TokenSyntax {
    SyntaxFactory.makeIfKeyword()
  }
  
/// The `guard` keyword
static var `guard`: TokenSyntax {
    SyntaxFactory.makeGuardKeyword()
  }
  
/// The `do` keyword
static var `do`: TokenSyntax {
    SyntaxFactory.makeDoKeyword()
  }
  
/// The `repeat` keyword
static var `repeat`: TokenSyntax {
    SyntaxFactory.makeRepeatKeyword()
  }
  
/// The `else` keyword
static var `else`: TokenSyntax {
    SyntaxFactory.makeElseKeyword()
  }
  
/// The `for` keyword
static var `for`: TokenSyntax {
    SyntaxFactory.makeForKeyword()
  }
  
/// The `in` keyword
static var `in`: TokenSyntax {
    SyntaxFactory.makeInKeyword()
  }
  
/// The `while` keyword
static var `while`: TokenSyntax {
    SyntaxFactory.makeWhileKeyword()
  }
  
/// The `return` keyword
static var `return`: TokenSyntax {
    SyntaxFactory.makeReturnKeyword()
  }
  
/// The `break` keyword
static var `break`: TokenSyntax {
    SyntaxFactory.makeBreakKeyword()
  }
  
/// The `continue` keyword
static var `continue`: TokenSyntax {
    SyntaxFactory.makeContinueKeyword()
  }
  
/// The `fallthrough` keyword
static var `fallthrough`: TokenSyntax {
    SyntaxFactory.makeFallthroughKeyword()
  }
  
/// The `switch` keyword
static var `switch`: TokenSyntax {
    SyntaxFactory.makeSwitchKeyword()
  }
  
/// The `case` keyword
static var `case`: TokenSyntax {
    SyntaxFactory.makeCaseKeyword()
  }
  
/// The `default` keyword
static var `default`: TokenSyntax {
    SyntaxFactory.makeDefaultKeyword()
  }
  
/// The `where` keyword
static var `where`: TokenSyntax {
    SyntaxFactory.makeWhereKeyword()
  }
  
/// The `catch` keyword
static var `catch`: TokenSyntax {
    SyntaxFactory.makeCatchKeyword()
  }
  
/// The `throw` keyword
static var `throw`: TokenSyntax {
    SyntaxFactory.makeThrowKeyword()
  }
  
/// The `as` keyword
static var `as`: TokenSyntax {
    SyntaxFactory.makeAsKeyword()
  }
  
/// The `Any` keyword
static var `any`: TokenSyntax {
    SyntaxFactory.makeAnyKeyword()
  }
  
/// The `false` keyword
static var `false`: TokenSyntax {
    SyntaxFactory.makeFalseKeyword()
  }
  
/// The `is` keyword
static var `is`: TokenSyntax {
    SyntaxFactory.makeIsKeyword()
  }
  
/// The `nil` keyword
static var `nil`: TokenSyntax {
    SyntaxFactory.makeNilKeyword()
  }
  
/// The `rethrows` keyword
static var `rethrows`: TokenSyntax {
    SyntaxFactory.makeRethrowsKeyword()
  }
  
/// The `super` keyword
static var `super`: TokenSyntax {
    SyntaxFactory.makeSuperKeyword()
  }
  
/// The `self` keyword
static var `self`: TokenSyntax {
    SyntaxFactory.makeSelfKeyword()
  }
  
/// The `Self` keyword
static var `capitalSelf`: TokenSyntax {
    SyntaxFactory.makeCapitalSelfKeyword()
  }
  
/// The `true` keyword
static var `true`: TokenSyntax {
    SyntaxFactory.makeTrueKeyword()
  }
  
/// The `try` keyword
static var `try`: TokenSyntax {
    SyntaxFactory.makeTryKeyword()
  }
  
/// The `throws` keyword
static var `throws`: TokenSyntax {
    SyntaxFactory.makeThrowsKeyword()
  }
  
/// The `__FILE__` keyword
static var `__FILE__`: TokenSyntax {
    SyntaxFactory.make__FILE__Keyword()
  }
  
/// The `__LINE__` keyword
static var `__LINE__`: TokenSyntax {
    SyntaxFactory.make__LINE__Keyword()
  }
  
/// The `__COLUMN__` keyword
static var `__COLUMN__`: TokenSyntax {
    SyntaxFactory.make__COLUMN__Keyword()
  }
  
/// The `__FUNCTION__` keyword
static var `__FUNCTION__`: TokenSyntax {
    SyntaxFactory.make__FUNCTION__Keyword()
  }
  
/// The `__DSO_HANDLE__` keyword
static var `__DSO_HANDLE__`: TokenSyntax {
    SyntaxFactory.make__DSO_HANDLE__Keyword()
  }
  
/// The `_` keyword
static var `wildcard`: TokenSyntax {
    SyntaxFactory.makeWildcardKeyword()
  }
  
/// The `(` token
static var `leftParen`: TokenSyntax {
    SyntaxFactory.makeLeftParenToken()
  }
  
/// The `)` token
static var `rightParen`: TokenSyntax {
    SyntaxFactory.makeRightParenToken()
  }
  
/// The `{` token
static var `leftBrace`: TokenSyntax {
    SyntaxFactory.makeLeftBraceToken()
  }
  
/// The `}` token
static var `rightBrace`: TokenSyntax {
    SyntaxFactory.makeRightBraceToken()
  }
  
/// The `[` token
static var `leftSquareBracket`: TokenSyntax {
    SyntaxFactory.makeLeftSquareBracketToken()
  }
  
/// The `]` token
static var `rightSquareBracket`: TokenSyntax {
    SyntaxFactory.makeRightSquareBracketToken()
  }
  
/// The `<` token
static var `leftAngle`: TokenSyntax {
    SyntaxFactory.makeLeftAngleToken()
  }
  
/// The `>` token
static var `rightAngle`: TokenSyntax {
    SyntaxFactory.makeRightAngleToken()
  }
  
/// The `.` token
static var `period`: TokenSyntax {
    SyntaxFactory.makePeriodToken()
  }
  
/// The `.` token
static var `prefixPeriod`: TokenSyntax {
    SyntaxFactory.makePrefixPeriodToken()
  }
  
/// The `,` token
static var `comma`: TokenSyntax {
    SyntaxFactory.makeCommaToken()
  }
  
/// The `...` token
static var `ellipsis`: TokenSyntax {
    SyntaxFactory.makeEllipsisToken()
  }
  
/// The `:` token
static var `colon`: TokenSyntax {
    SyntaxFactory.makeColonToken()
  }
  
/// The `;` token
static var `semicolon`: TokenSyntax {
    SyntaxFactory.makeSemicolonToken()
  }
  
/// The `=` token
static var `equal`: TokenSyntax {
    SyntaxFactory.makeEqualToken()
  }
  
/// The `@` token
static var `atSign`: TokenSyntax {
    SyntaxFactory.makeAtSignToken()
  }
  
/// The `#` token
static var `pound`: TokenSyntax {
    SyntaxFactory.makePoundToken()
  }
  
/// The `&` token
static var `prefixAmpersand`: TokenSyntax {
    SyntaxFactory.makePrefixAmpersandToken()
  }
  
/// The `->` token
static var `arrow`: TokenSyntax {
    SyntaxFactory.makeArrowToken()
  }
  
/// The ``` token
static var `backtick`: TokenSyntax {
    SyntaxFactory.makeBacktickToken()
  }
  
/// The `\` token
static var `backslash`: TokenSyntax {
    SyntaxFactory.makeBackslashToken()
  }
  
/// The `!` token
static var `exclamationMark`: TokenSyntax {
    SyntaxFactory.makeExclamationMarkToken()
  }
  
/// The `?` token
static var `postfixQuestionMark`: TokenSyntax {
    SyntaxFactory.makePostfixQuestionMarkToken()
  }
  
/// The `?` token
static var `infixQuestionMark`: TokenSyntax {
    SyntaxFactory.makeInfixQuestionMarkToken()
  }
  
/// The `"` token
static var `stringQuote`: TokenSyntax {
    SyntaxFactory.makeStringQuoteToken()
  }
  
/// The `'` token
static var `singleQuote`: TokenSyntax {
    SyntaxFactory.makeSingleQuoteToken()
  }
  
/// The `"""` token
static var `multilineStringQuote`: TokenSyntax {
    SyntaxFactory.makeMultilineStringQuoteToken()
  }
  
/// The `#keyPath` keyword
static var `poundKeyPath`: TokenSyntax {
    SyntaxFactory.makePoundKeyPathKeyword()
  }
  
/// The `#line` keyword
static var `poundLine`: TokenSyntax {
    SyntaxFactory.makePoundLineKeyword()
  }
  
/// The `#selector` keyword
static var `poundSelector`: TokenSyntax {
    SyntaxFactory.makePoundSelectorKeyword()
  }
  
/// The `#file` keyword
static var `poundFile`: TokenSyntax {
    SyntaxFactory.makePoundFileKeyword()
  }
  
/// The `#fileID` keyword
static var `poundFileID`: TokenSyntax {
    SyntaxFactory.makePoundFileIDKeyword()
  }
  
/// The `#filePath` keyword
static var `poundFilePath`: TokenSyntax {
    SyntaxFactory.makePoundFilePathKeyword()
  }
  
/// The `#column` keyword
static var `poundColumn`: TokenSyntax {
    SyntaxFactory.makePoundColumnKeyword()
  }
  
/// The `#function` keyword
static var `poundFunction`: TokenSyntax {
    SyntaxFactory.makePoundFunctionKeyword()
  }
  
/// The `#dsohandle` keyword
static var `poundDsohandle`: TokenSyntax {
    SyntaxFactory.makePoundDsohandleKeyword()
  }
  
/// The `#assert` keyword
static var `poundAssert`: TokenSyntax {
    SyntaxFactory.makePoundAssertKeyword()
  }
  
/// The `#sourceLocation` keyword
static var `poundSourceLocation`: TokenSyntax {
    SyntaxFactory.makePoundSourceLocationKeyword()
  }
  
/// The `#warning` keyword
static var `poundWarning`: TokenSyntax {
    SyntaxFactory.makePoundWarningKeyword()
  }
  
/// The `#error` keyword
static var `poundError`: TokenSyntax {
    SyntaxFactory.makePoundErrorKeyword()
  }
  
/// The `#if` keyword
static var `poundIf`: TokenSyntax {
    SyntaxFactory.makePoundIfKeyword()
  }
  
/// The `#else` keyword
static var `poundElse`: TokenSyntax {
    SyntaxFactory.makePoundElseKeyword()
  }
  
/// The `#elseif` keyword
static var `poundElseif`: TokenSyntax {
    SyntaxFactory.makePoundElseifKeyword()
  }
  
/// The `#endif` keyword
static var `poundEndif`: TokenSyntax {
    SyntaxFactory.makePoundEndifKeyword()
  }
  
/// The `#available` keyword
static var `poundAvailable`: TokenSyntax {
    SyntaxFactory.makePoundAvailableKeyword()
  }
  
/// The `#unavailable` keyword
static var `poundUnavailable`: TokenSyntax {
    SyntaxFactory.makePoundUnavailableKeyword()
  }
  
/// The `#fileLiteral` keyword
static var `poundFileLiteral`: TokenSyntax {
    SyntaxFactory.makePoundFileLiteralKeyword()
  }
  
/// The `#imageLiteral` keyword
static var `poundImageLiteral`: TokenSyntax {
    SyntaxFactory.makePoundImageLiteralKeyword()
  }
  
/// The `#colorLiteral` keyword
static var `poundColorLiteral`: TokenSyntax {
    SyntaxFactory.makePoundColorLiteralKeyword()
  }
  static func `integerLiteral`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeIntegerLiteral(text)
  }
  static func `floatingLiteral`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeFloatingLiteral(text)
  }
  static func `stringLiteral`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeStringLiteral(text)
  }
  static func `regexLiteral`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeRegexLiteral(text)
  }
  static func `unknown`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeUnknown(text)
  }
  static func `identifier`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeIdentifier(text)
  }
  static func `unspacedBinaryOperator`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeUnspacedBinaryOperator(text)
  }
  static func `spacedBinaryOperator`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeSpacedBinaryOperator(text)
  }
  static func `postfixOperator`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makePostfixOperator(text)
  }
  static func `prefixOperator`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makePrefixOperator(text)
  }
  static func `dollarIdentifier`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeDollarIdentifier(text)
  }
  static func `contextualKeyword`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeContextualKeyword(text)
  }
  static func `rawStringDelimiter`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeRawStringDelimiter(text)
  }
  static func `stringSegment`(_ text: String) -> TokenSyntax {
    SyntaxFactory.makeStringSegment(text)
  }
  
/// The `)` token
static var `stringInterpolationAnchor`: TokenSyntax {
    SyntaxFactory.makeStringInterpolationAnchorToken()
  }
  
/// The `yield` token
static var `yield`: TokenSyntax {
    SyntaxFactory.makeYieldToken()
  }
  
/// The `eof` token
static var eof: TokenSyntax {
    SyntaxFactory.makeToken(.eof, presence: .present)
  }
  
/// The `open` contextual token
static var open: TokenSyntax {
    SyntaxFactory.makeContextualKeyword("open")
    .withTrailingTrivia(.space)
  }
}